#!/bin/bash
set -o nounset -o pipefail -o errexit

# openai-proxy - Use custom routes for OpenAI API endpoints

# Color constants
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color
BOLD='\033[1m'

command -v realpath &> /dev/null || {
  echo "Error: 'realpath' is required but not found. Please install 'coreutils' (e.g. 'brew install coreutils' on macOS)." >&2
  exit 1
}
SCRIPT_DIR="$(dirname -- "$(realpath "${BASH_SOURCE[0]}")")"
export PATH="$SCRIPT_DIR:$PATH"

# Socket handling functions
function get_socket_path() {
    # Check if running as root/sudo
    if [ "$EUID" -eq 0 ]; then
        # System-wide location when running as root
        echo "/var/run/openai-proxy/haproxy.sock"
    else
        # User-specific location
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS: Use user's Library directory
            echo "$HOME/Library/Application Support/openai-proxy/haproxy.sock"
        else
            # Linux/Unix: Use XDG_RUNTIME_DIR if available, fall back to /tmp
            local runtime_dir="${XDG_RUNTIME_DIR:-/tmp}/openai-proxy"
            echo "$runtime_dir/haproxy.sock"
        fi
    fi
}

function prepare_socket_directory() {
    local socket_path
    socket_path=$(dirname "$(get_socket_path)")
    
    if [ ! -d "$socket_path" ]; then
        mkdir -p "$socket_path"
        # Set appropriate permissions
        if [ "$EUID" -eq 0 ]; then
            chmod 755 "$socket_path"
        else
            chmod 700 "$socket_path"
        fi
    fi
}

# Default environment variables
PORT=${PORT:-2020}
TEMPLATE=${TEMPLATE:-${SCRIPT_DIR}/../config/haproxy/openai-proxy.cfg.template}
CONFIG=${CONFIG:-${SCRIPT_DIR}/../config/haproxy/openai-proxy.cfg}
ENV_FILE=${ENV_FILE:-${SCRIPT_DIR}/../config/env}
ERROR_PAGE=${ERROR_PAGE:-${SCRIPT_DIR}/../config/haproxy/errors/503.http}
SOCKET=${SOCKET:-$(get_socket_path)}

# Function to display help
function show_help() {
    echo "Usage: openai-proxy [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  start    Start the proxy (default if no command specified)"
    echo "  stop     Stop the proxy"
    echo "  restart  Stop and then start the proxy"
    echo "  reload   Reload the configuration without stopping"
    echo "  status   Show proxy status"
    echo ""
    echo "Options:"
    echo "  -h, --help            Show this help message and exit"
    echo "  -v, --version         Show version information and exit"
    echo "  -b, --bind ADDRESS    Specify the IP address to bind to (default: 127.0.0.1)"
    echo "  -p, --port PORT       Specify the port to listen on (default: 2020)"
    echo "  -c, --config FILE     Specify the config file path"
    echo "      --verbose         Enable verbose output"
    echo "      --debug           Enable debug output"
}

function show_version() {
    echo "openai-proxy version 1.0.0"
}

function check_dependencies() {
    local deps=("$@")
    local missing=0
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            echo "Error: $dep is not installed."
            echo "Please install $dep and try again."
            missing=1
        fi
    done
    
    [ $missing -eq 1 ] && exit 1
    return 0
}

function get_pid() {
    # Return all PIDs as a space-separated list
    pgrep -f "haproxy.*$CONFIG" | tr '\n' ' ' || true
}

function get_backend_status() {
    local backend=$1
    if [ -S "${SOCKET}" ]; then
        local status=$(echo "show stat" | socat "${SOCKET}" stdio | grep "${backend}" | grep 'BACKEND' | cut -d',' -f18)
        if [ "$status" = "UP" ]; then
            echo -e "${GREEN}●${NC} UP"
        elif [ "$status" = "DOWN" ]; then
            echo -e "${RED}●${NC} DOWN"
        else
            echo -e "${YELLOW}●${NC} UNKNOWN"
        fi
    else
        echo -e "${YELLOW}●${NC} NO STATS (socket not found)"
    fi
}

function show_routing_table() {
    echo -e "${BOLD}OpenAI API Routing Table${NC}\n"

    # Audio Transcriptions
    printf "%s %-30s ${BLUE}%-40s${NC}\n" \
        "$(get_backend_status "backend_audio_transcriptions")" \
        "/v1/audio/transcriptions" \
        "$BACKEND_AUDIO_TRANSCRIPTIONS"

    # Chat Completions
    printf "%s %-30s ${BLUE}%-40s${NC}\n" \
        "$(get_backend_status "backend_chat_completions")" \
        "/v1/chat/completions" \
        "$BACKEND_CHAT_COMPLETIONS"

    # Text to Speech
    printf "%s %-30s ${BLUE}%-40s${NC}\n" \
        "$(get_backend_status "backend_audio_speech")" \
        "/v1/audio/speech" \
        "$BACKEND_AUDIO_SPEECH"

    echo -e "\n${BOLD}OpenAI API Backend:${NC} ${BLUE}${BACKEND_OPENAI}${NC}"
    echo -e "\nListening on: ${GREEN}http://0.0.0.0:${PORT}${NC}"
}

function reload_command() {
    local pids
    pids=$(get_pid)
    if [ -n "$pids" ]; then
        generate_haproxy_config
        echo -e "${YELLOW}Reloading openai-proxy configuration...${NC}"
        # Convert space-separated PIDs into -sf pid1 -sf pid2 format
        local sf_args=""
        for pid in $pids; do
            sf_args="$sf_args -sf $pid"
        done
        haproxy -f "$CONFIG" $sf_args
        echo -e "${GREEN}Configuration reloaded${NC}"
        show_routing_table
    else
        echo -e "${RED}openai-proxy is not running${NC}"
        return 1
    fi
}

function restart_command() {
    stop_command
    sleep 1
    # Generate new config before starting
    generate_haproxy_config
    start_command
}

function status_command() {
    local pid
    pid=$(get_pid)
    if [ -n "$pid" ]; then
        echo -e "${GREEN}openai-proxy is running (PID: $pid)${NC}\n"
        show_routing_table
        return 0
    else
        echo -e "${RED}openai-proxy is not running${NC}"
        return 1
    fi
}

function stop_command() {
    local pids
    pids=$(get_pid)
    if [ -n "$pids" ]; then
        echo "Stopping openai-proxy (PIDs: $pids)..."
        for pid in $pids; do
            kill "$pid" 2>/dev/null || true
        done
        # Wait for all processes to stop with timeout
        local timeout=10
        local count=0
        while [ $count -lt $timeout ]; do
            pids=$(get_pid)
            if [ -z "$pids" ]; then
                echo "Stopped"
                return 0
            fi
            sleep 1
            count=$((count + 1))
        done
        echo -e "${RED}Failed to stop all processes after $timeout seconds${NC}"
        return 1
    else
        echo "openai-proxy is not running"
        return 0  # Changed to return 0 since this isn't really an error
    fi
}

function start_command() {
    # Check if already running
    local pid
    pid=$(get_pid)
    if [ -n "$pid" ]; then
        echo -e "${RED}openai-proxy is already running (PID: $pid)${NC}"
        return 1
    fi

    # Ensure socket directory exists
    prepare_socket_directory

    # Generate the config
    generate_haproxy_config

    # Start HAProxy
    echo "Starting openai-proxy..."
    if [ "$DEBUG" -eq 1 ]; then
        haproxy -f "$CONFIG" -d
    else
        haproxy -f "$CONFIG"
    fi

    # Wait briefly and verify process started
    sleep 1
    pid=$(get_pid)
    if [ -z "$pid" ]; then
        echo -e "${RED}Failed to start openai-proxy${NC}"
        return 1
    fi

    echo -e "\n${GREEN}OpenAI Proxy started successfully${NC}\n"
    show_routing_table
}

function get_backend_names() {
    # Extract all backend names from the template file
    grep "^backend backend_" "$TEMPLATE" | \
    sed 's/^backend backend_//' | \
    tr '\n' ' '
}

# Parse a backend URL into component parts
function parse_backend_url() {
    local var_prefix="$1"      # e.g. BACKEND_DEFAULT
    local env_var="${var_prefix}"  # Construct the full env var name
    
    # Use eval to get the URL value since we're dealing with dynamic variable names
    local url
    eval "url=\${$env_var}"
    
    # Extract protocol, host, port
    if [[ "$url" =~ ^(https?)://([^:/]+)(:([0-9]+))? ]]; then
        local proto="${BASH_REMATCH[1]}"
        local host="${BASH_REMATCH[2]}"
        local port="${BASH_REMATCH[4]}"
        
        # Set default ports if not specified
        [[ -z "$port" ]] && port=$([ "$proto" = "https" ] && echo "443" || echo "80")
        
        # Export parsed components
        export "${var_prefix}_HOST"="$host"
        export "${var_prefix}_PORT"="$port"
        export "${var_prefix}_SSL"="$([ "$proto" = "https" ] && echo "1" || echo "0")"
    fi
}

function prepare_backend_variables() {
    # Get backend names dynamically from template
    local backend_names
    backend_names=$(get_backend_names)
    
    # Process each backend
    for name in $backend_names; do
        local backend="BACKEND_${name^^}"
        parse_backend_url "$backend"
        
        # Create the SSL config string if SSL is enabled
        local ssl_var="${backend}_SSL"
        if [ "${!ssl_var}" = "1" ]; then
            local host_var="${backend}_HOST"
            export "${backend}_SSL_CONFIG=ssl verify none sni str(${!host_var})"
        else
            export "${backend}_SSL_CONFIG="
        fi
    done
}

function generate_haproxy_config() {
    # Set logging variables based on debug mode
    if [ "$DEBUG" -eq 1 ]; then
        export LOG_LEVEL="debug"
        export HAPROXY_LOG_CONFIG='log-format "%ci:%cp [%tr] %ft %b/%s %TR/%Tw/%Tc/%Tr/%Ta %ST %B %CC %CS %tsc %ac/%fc/%bc/%sc/%rc %sq/%bq %hr %hs %{+Q}r"'
    else
        export LOG_LEVEL="notice"
        export HAPROXY_LOG_CONFIG="option httplog"
    fi

    # Parse backend URLs into component variables
    prepare_backend_variables

    # Export variables needed by envsubst
    export PORT
    export ERROR_PAGE
    export SOCKET 

    # Generate HAProxy configuration using envsubst
    echo -e "${BLUE}Regenerating HAProxy configuration...${NC}"
    envsubst < "$TEMPLATE" > "$CONFIG"

    if [ "$VERBOSE" -eq 1 ]; then
        echo "Generated configuration:"
        cat "$CONFIG"
    fi
}


function load_configuration() {
    # Configuration values are loaded in order, with later sources taking precedence:
    #
    # 1. Default values (lowest precedence)
    # 2. ENV file variables (if present)
    # 3. Environment variables with OPENAI_PROXY_ prefix
    # 4. Command line arguments (highest precedence, handled in main())

    # Start with default values
    PORT="2020"
    BIND_IP="127.0.0.1"
    BACKEND_AUDIO_TRANSCRIPTIONS="https://api.openai.com:443"
    BACKEND_AUDIO_SPEECH="https://api.openai.com:443"
    BACKEND_CHAT_COMPLETIONS="https://api.openai.com:443"
    BACKEND_OPENAI="https://api.openai.com:443"
    BACKEND_LOCAL="http://localhost"  # Local backend for static content
    WELCOME_PAGE="$(realpath "${SCRIPT_DIR}/../config/haproxy/pages/welcome.http")"

    # Load from ENV file if present (overrides defaults)
    [ -f "$ENV_FILE" ] && source "$ENV_FILE"

    # Override with environment variables if set
    BACKEND_AUDIO_SPEECH="${OPENAI_PROXY_BACKEND_AUDIO_SPEECH:-$BACKEND_AUDIO_SPEECH}"
    BACKEND_AUDIO_TRANSCRIPTIONS="${OPENAI_PROXY_BACKEND_AUDIO_TRANSCRIPTIONS:-$BACKEND_AUDIO_TRANSCRIPTIONS}"
    BACKEND_CHAT_COMPLETIONS="${OPENAI_PROXY_BACKEND_CHAT_COMPLETIONS:-$BACKEND_CHAT_COMPLETIONS}"
    BACKEND_OPENAI="${OPENAI_PROXY_BACKEND_OPENAI:-$BACKEND_OPENAI}"
    BIND_IP="${OPENAI_PROXY_BIND_IP:-$BIND_IP}"
    PORT="${OPENAI_PROXY_PORT:-$PORT}"

    # Export all variables for use in templates and rest of script
    export BACKEND_AUDIO_SPEECH
    export BACKEND_AUDIO_TRANSCRIPTIONS
    export BACKEND_CHAT_COMPLETIONS
    export BACKEND_OPENAI
    export BACKEND_LOCAL
    export BIND_IP
    export PORT
    export WELCOME_PAGE
}

function process_arguments() {
    export VERBOSE=0
    export DEBUG=0
    export COMMAND="start"

    while [[ $# -gt 0 ]]; do
        case $1 in
            start|stop|status|reload|restart)
            export COMMAND="$1"
            shift
            ;;
            -b|--bind)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: --bind requires an IP address argument" >&2
                exit 1
            fi
            export BIND_IP="$2"
            shift
            shift
            ;;
            -p|--port)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: --port requires a port number argument" >&2
                exit 1
            fi
            if ! [[ "$2" =~ ^[0-9]+$ ]] || [ "$2" -lt 1 ] || [ "$2" -gt 65535 ]; then
                echo "Error: port must be a number between 1 and 65535" >&2
                exit 1
            fi
            export PORT="$2"
            shift
            shift
            ;;
            -h|--help)
            show_help
            exit 0
            ;;
            -v|--version)
            show_version
            exit 0
            ;;
            -c|--config)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: --config requires a file argument" >&2
                exit 1
            fi
            export ENV_FILE="$2"
            shift
            shift
            ;;
            --verbose)
            export VERBOSE=1
            shift
            ;;
            --debug)
            export DEBUG=1
            shift
            ;;
            *)
            echo "Unknown option: $1" >&2
            show_help
            exit 1
            ;;
        esac
    done

}

function main() {
    # Load configuration from env file and set defaults
    load_configuration

    # Check for required dependencies
    check_dependencies haproxy envsubst socat

    # Process command line arguments
    process_arguments "$@"

    # Execute the requested command
    case "$COMMAND" in
        start)
            start_command
            ;;
        stop)
            stop_command
            ;;
        restart)
            restart_command
            ;;
        reload)
            reload_command
            ;;
        status)
            status_command
            ;;
        *)
            echo "Unknown command: $COMMAND"
            show_help
            exit 1
            ;;
    esac
}

# Call main with all script arguments
main "$@"
