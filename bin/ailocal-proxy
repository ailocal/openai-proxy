#!/usr/bin/env python

# ailocal-proxy - Redirect transcription requests to self hosted Whisper.
#
# This script sets up a local proxy server that intercepts OpenAI API calls
# and redirects Whisper transcription requests to a custom endpoint.
#
# Usage:
# 1. Set the WHISPER_API_ENDPOINT environment variable to your custom endpoint.
# 2. Run this script: ailocal-proxy
# 3. Set OPENAI_API_BASE=http://localhost:2020 when running your main application.
#
# The proxy will redirect Whisper requests to your custom endpoint and
# forward all other OpenAI API requests to the actual OpenAI API.

import http.server
import socketserver
import urllib.request
import os
import logging
import signal
import sys
import threading
import json

# Set up logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

AILOCAL_PROXY_PORT = int(os.getenv('AILOCAL_PROXY_PORT', 2020))
WHISPER_API_ENDPOINT = os.getenv('AILOCAL_WHISPER_API_ENDPOINT', 'https://api.ailocal.org/audio/transcriptions')
OPENAI_API_HOST = os.getenv('AILOCAL_OPENAI_API_HOST', 'api.openai.com')
DEBUG_MODE = os.getenv('AILOCAL_PROXY_DEBUG', 'true').lower() == 'true'

logging.info(f"WHISPER_API_ENDPOINT: {WHISPER_API_ENDPOINT}")
logging.info(f"OPENAI_API_HOST: {OPENAI_API_HOST}")
logging.info(f"DEBUG_MODE: {DEBUG_MODE}")

class WhisperProxyHandler(http.server.BaseHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
        self.body = None
        super().__init__(*args, **kwargs)

    def log_request_info(self):
        if DEBUG_MODE:
            logging.debug(f"--- Incoming Request ---")
            logging.debug(f"Method: {self.command}")
            logging.debug(f"Path: {self.path}")
            logging.debug(f"Headers: {self.headers}")
            if self.command in ['POST', 'PUT', 'PATCH']:
                content_length = int(self.headers.get('Content-Length', 0))
                self.body = self.rfile.read(content_length)
                try:
                    logging.debug(f"Body: {self.body.decode('utf-8')}")
                except UnicodeDecodeError:
                    logging.debug(f"Body: [binary data, length: {len(self.body)} bytes]")
            logging.debug("------------------------")

    def do_OPTIONS(self):
        self.log_request_info()
        self.send_response(200)
        self.send_header('Allow', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type, Authorization')
        self.end_headers()

    def do_GET(self):
        self.log_request_info()
        self.send_error(405, "Method Not Allowed")

    def do_POST(self):
        self.log_request_info()
        post_data = self.body
        
        logging.info(f"Incoming POST request URL: {self.path}")
       
        print(self.path) 
        if self.path.startswith('/v1/audio/transcriptions') or self.path == '/audio/transcriptions':
            # Forward the request to the local Whisper API
            logging.info(f"Forwarding Whisper request to: {WHISPER_API_ENDPOINT}")
            logging.info(f"Original request path: {self.path}")
            req = urllib.request.Request(WHISPER_API_ENDPOINT, data=post_data, headers=self.headers)
            try:
                with urllib.request.urlopen(req) as response:
                    self.send_response(response.status)
                    for key, value in response.headers.items():
                        self.send_header(key, value)
                    self.end_headers()
                    response_data = response.read()
                    self.wfile.write(response_data)
                    if DEBUG_MODE:
                        logging.debug(f"Response from Whisper API: {response_data.decode('utf-8')}")
            except urllib.error.URLError as e:
                self.send_error(500, f"Error forwarding to Whisper API: {str(e)}")
        else:
            # For other requests, forward to the actual OpenAI API
            url = f'https://{OPENAI_API_HOST}{self.path}'
            logging.info(f"Forwarding to OpenAI API: {url}")
            req = urllib.request.Request(url, data=post_data, headers=self.headers)
            try:
                with urllib.request.urlopen(req) as response:
                    self.send_response(response.status)
                    for key, value in response.headers.items():
                        self.send_header(key, value)
                    self.end_headers()
                    response_data = response.read()
                    self.wfile.write(response_data)
                    if DEBUG_MODE:
                        logging.debug(f"Response from OpenAI API: {response_data.decode('utf-8')}")
            except urllib.error.URLError as e:
                self.send_error(500, f"Error forwarding to OpenAI API: {str(e)}")

def run_proxy(port=AILOCAL_PROXY_PORT):
    httpd = socketserver.TCPServer(("", port), WhisperProxyHandler)
    httpd.allow_reuse_address = True
    
    shutdown_event = threading.Event()

    def signal_handler(sig, frame):
        logging.info("Shutting down the server...")
        shutdown_event.set()

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    server_thread = threading.Thread(target=httpd.serve_forever)
    server_thread.start()

    logging.info(f"Serving Whisper proxy on port {port}")
    
    try:
        while not shutdown_event.is_set():
            shutdown_event.wait(1)
    except Exception as e:
        logging.error(f"Error occurred: {e}")
    finally:
        httpd.shutdown()
        server_thread.join()
        httpd.server_close()
        logging.info("Server has been shut down.")

if __name__ == "__main__":
    run_proxy()
